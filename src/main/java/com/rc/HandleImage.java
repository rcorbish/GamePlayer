package com.rc;

import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import java.awt.image.DataBuffer;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Base64;
import java.util.Date;
import java.util.Random;

import javax.imageio.ImageIO;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import spark.Request;
import spark.Response;

public class HandleImage {
	static Logger logger = LoggerFactory.getLogger( HandleImage.class ) ;
	public static int TARGET_WIDTH = 128 ;
	public static int TARGET_HEIGHT = 128 ;
	public static int TARGET_CHANNELS = 3 ;
	private Random rng ;
	private Dense dense ;
	private SaveData saver ;
	private int numi = 100 ;
	File rootDir = new File("src/main/resources/screens" ) ;
	File trainDir = new File( rootDir, "train" ) ;
	File testDir = new File( rootDir, "test" ) ;
	
	public HandleImage() throws ClassNotFoundException, IOException {
		dense = null ;
		saver = null ;
		rng = new Random( 1960 ) ;
		
		try ( FileWriter fw = new FileWriter( new File( rootDir, "env.sh"), false ) ) {
			fw.write( "# Auto generated by HandleImage - " + new Date() );
			fw.write( "\nTARGET_WIDTH=" + TARGET_WIDTH );
			fw.write( "\nTARGET_HEIGHT=" + TARGET_HEIGHT );
			fw.write( "\nTARGET_CHANNELS=" + TARGET_CHANNELS );
			fw.flush();
		}
		new Thread( new Runnable() {
			public void run() {
				Thread.currentThread().setName( "Network Creator" ) ;
				try {
					logger.info( "Creating network in the background" );
					dense = new Dense( TARGET_WIDTH, TARGET_HEIGHT, TARGET_CHANNELS ) ;
					logger.info( "Network ready to play" ) ;
				} catch (ClassNotFoundException | IOException e) {
					logger.error( "Cannot create dense network", e ); 
				}
			}
		} ).start() ;
	}
	
	public String post( Request req, Response rsp ) {
		try { 
			String from = req.headers( "X-Game-Instance" ) ;
			String mode = req.headers( "X-Server-Mode" ) ;
			if( mode==null ) mode = "save" ;

			String tmp = req.params( "score" ) ;
			int score = Integer.parseInt(tmp) ;

			tmp = req.params( "x" ) ;			
			float x = tmp==null ? 0 : Float.parseFloat(tmp) ;
			tmp = req.params( "y" ) ;			
			float y = tmp==null ? 0 : Float.parseFloat(tmp) ;
			tmp = req.params( "fire" ) ;			
			boolean fire = Boolean.parseBoolean(tmp) ;
			
			logger.debug( "POST: score={}, x={}, y={}, fire={}", score,x,y,fire ) ;

			String base64 = req.body() ;
			//byte raw[] = req.bodyAsBytes() ;
			int ix = base64.indexOf(',') ;
			byte raw[] = Base64.getDecoder().decode( base64.substring( ix+1 ) ) ;
			BufferedImage colorImage = ImageIO.read( new ByteArrayInputStream(raw) ) ;
			numi++ ;
			
			BufferedImage scaledImage = new BufferedImage( TARGET_WIDTH, TARGET_HEIGHT, 
						TARGET_CHANNELS==1 ? BufferedImage.TYPE_BYTE_GRAY : BufferedImage.TYPE_3BYTE_BGR ) ;
			Graphics2D gi = scaledImage.createGraphics();
		    gi.setRenderingHint(
		    	    RenderingHints.KEY_INTERPOLATION,
		    	    RenderingHints.VALUE_INTERPOLATION_BILINEAR
		    	);
		    gi.drawImage(colorImage, 0, 0, TARGET_WIDTH, TARGET_HEIGHT, null );

		    int moveCode = SaveData.DataWriter.convertDataToIndex( x,y,fire ) ;
		    
		    File tgtDir = new File( rng.nextFloat()<0.2f ? testDir : trainDir , String.valueOf(moveCode) ) ;
		    tgtDir.mkdirs() ;
			File outputfile = File.createTempFile("screen.", ".bmp", tgtDir ) ;
			ImageIO.write(scaledImage, "bmp", outputfile);

		    DataBuffer db = scaledImage.getRaster().getDataBuffer() ;
		    logger.debug( "Image reduced" ) ;
		    ProposedMove rc = ProposedMove.NULL_MOVE ;
		    if( "play".equals(mode) ) {
		    	if( dense != null ) {
		    		rc = dense.processData( db ) ;
		    	}
		    } else if( "save".equals(mode) ) {
		    	if( saver == null ) saver = new SaveData( TARGET_WIDTH, TARGET_HEIGHT, TARGET_CHANNELS ) ;
		    	rc = saver.processData( db, from, score, x, y, fire ) ;
		    }
		    logger.debug( "Sending {} as a response.", rc.toJson() ) ;
			return rc.toJson() ;
		} catch( Throwable t ) {
			t.printStackTrace(); 
			throw new RuntimeException( t ) ;
		}
	}
}
